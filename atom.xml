<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr_DuanのBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-02T07:39:40.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Mr duan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/12/02/SPI%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9C%A8Mcal%E4%B8%AD%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2023/12/02/SPI%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9C%A8Mcal%E4%B8%AD%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</id>
    <published>2023-12-02T15:43:18.688Z</published>
    <updated>2023-12-02T07:39:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SPI介绍及在Mcal中相关配置"><a href="#SPI介绍及在Mcal中相关配置" class="headerlink" title="SPI介绍及在Mcal中相关配置"></a>SPI介绍及在Mcal中相关配置</h1><aside>💡 SPI：Serial Peripheral Interface 串行外围接口，从名字中可以看出**串行，接口，**表明其通信方式为串行通信。</aside><p>SPI通信一般为四根信号，分为为SCK、CS、MOSI及MISO，其通信方式为全双工，有主设备和从设备之分，但是不存在收发设备之分，因为在主设备发送的同时也在接收者从设备的数据。其四个信号分别代表着：</p><p>SCK：系统时钟</p><p>CS：片选信号<br>MOSI：主发从收</p><p>MISO：主收从发</p><p><img src="SPI%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9C%A8Mcal%E4%B8%AD%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%20f497bee52070403b8a1b543ee2fa63be/SPI_NORMAL.bmp" alt="SPI_NORMAL.bmp"></p><p>SPI通信的逻辑是：</p><aside>💡 1：主设备通过CS脚选中从设备（低有效/高有效）2：经过一段保持时间，CLK按照设置的频率开始工作3：MOSI和MISO分别发出数据</aside><p>其中，将片选之前CLK的初始相位和跳变沿开始采样的时间可以分为四种模式：</p><p>CPOL：Clock Polarity 信号极性，即在片选之前后CLK的初始相位为高（bit = 1）或低（bit = 0）<br>CPHA：Clock Phase 信号相位，即信号采样时处于一个信号周期的Leading时刻（bit = 0）还是Trailing时刻（bit = 1）</p><table><thead><tr><th>Mode</th><th>CPOL</th><th>CPHA</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>2</td><td>1</td><td>0</td></tr><tr><td>3</td><td>1</td><td>1</td></tr></tbody></table><p><img src="SPI%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9C%A8Mcal%E4%B8%AD%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%20f497bee52070403b8a1b543ee2fa63be/Untitled.bmp" alt="Untitled"></p><p><img src="SPI%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9C%A8Mcal%E4%B8%AD%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%20f497bee52070403b8a1b543ee2fa63be/Untitled%201.bmp" alt="Untitled"></p><p><img src="SPI%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9C%A8Mcal%E4%B8%AD%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%20f497bee52070403b8a1b543ee2fa63be/Untitled%202.bmp" alt="Untitled"></p><p><img src="SPI%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9C%A8Mcal%E4%B8%AD%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%20f497bee52070403b8a1b543ee2fa63be/Untitled%203.bmp" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SPI介绍及在Mcal中相关配置&quot;&gt;&lt;a href=&quot;#SPI介绍及在Mcal中相关配置&quot; class=&quot;headerlink&quot; title=&quot;SPI介绍及在Mcal中相关配置&quot;&gt;&lt;/a&gt;SPI介绍及在Mcal中相关配置&lt;/h1&gt;&lt;aside&gt;
💡 SPI：Se</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/09/06/CAN/"/>
    <id>http://example.com/2023/09/06/CAN/</id>
    <published>2023-09-06T15:54:50.974Z</published>
    <updated>2023-09-06T15:57:00.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAN通信"><a href="#CAN通信" class="headerlink" title="CAN通信"></a>CAN通信</h1><hr><p>title: Windows平台下基于Hexo搭建的个人博客<br>date: 2020-12-02 22：37：00<br>categories: 技术 </p><hr><h1 id="一：什么是CAN通信"><a href="#一：什么是CAN通信" class="headerlink" title="一：什么是CAN通信"></a>一：什么是CAN通信</h1><p>CAN通信全称 Controller Area Network，也称控制器区域网，最早由博世公司提出，用来应用于汽车电子领域，进而保证多个ECU之间的相互通信。</p><p>为什么博世要提出这个通信协议呢？在当时其他的通信标准不能用吗？</p><p>其实博世公司早在20世纪80年代就提出该标准，因为在当时那个年代，汽车上的ECU还不是特别多，OEM厂主要通过线与线直接连接的方式进行通信，需要MCU与每个ECU建立连接，这种方式在ECU少的情况下尚可，但如果出现了问题，诊断起来就非常困难。</p><p>此时博世的工程师就和德国几个高校的教授一起思考：有没有可能设计一种串行的通信方式，将所有的ECU挂载在总线上，通过仲裁的机制去访问不同的ECU，这样也可以避免线束过多，诊断起来也比较方便，于是乎，CAN通信就应运而生。让我们记住这几个大佬的名字：德国 Braunschweig-Wolfenbüttel 的Applied Science 大学教授 <strong>WolfhardLawrenz 博士，Karlsruhe大学的教授Horst Wettstein 博士，Bosch 公司的 Wolfgang Borst、 Wolfgang Botzenhard、Otto Karl、 Helmut Schelling、Jan Unruh，</strong>虽然我一定记不得名字，但是他们的事迹一定会一直存在在这个世界上。</p><p>由于CAN通信简单，使用，可靠的特点，后来不仅仅在汽车行业，也在自动化、船舶等诸多行业发展光大，一直到21世纪20年代，仍然可以说引领者串行通信行业的发展。</p><p>CAN网络是数字信号进行传输的，那么CAN的“0”和“1”怎么表示呢？这里就引入一个概念，CAN_H和CAN_L，我们通过这两个信号之间的电位差来对信号进行描述。</p><p>如果CAN_H-CAN_L = 0V ，那么我们定义其为CAN信号为隐形电平</p><p>如果CAN_H-CAN_L &gt; 1.5V ，那么此时我们定义CAN信号为显性电平，通常来说，这个压差只要满足1.5-2.5V之间，我们就可以认为其为显性电平。</p><p><img src="https://pic.imgdb.cn/item/64f8a056661c6c8e5412c155.png" alt="Untitled"></p><p>从图中我们也能看的出来，当隐性电平时，表示为逻辑1，当为显性电平时，表示为逻辑0。</p><p>为什么要这么做呢？直接像SPI那样从一根线表示0和1呢？非要用相减的方法？</p><p>这是因为采用这种方法可以大大得增加他的抗干扰能力，提高系统的稳定性。</p><h1 id="二：CAN通信的用法"><a href="#二：CAN通信的用法" class="headerlink" title="二：CAN通信的用法"></a>二：CAN通信的用法</h1><p>前面说了CAN通信的起源，那为什么说CAN通信一出来就这么好？他优势在哪里？串行总线又是个什么东西？</p><p><img src="https://pic.imgdb.cn/item/64f8a056661c6c8e5412c148.png"></p><p>从这个图，大致可以看出，全部的ECU挂在一条总线上，采用CAN通信，并没有主从之分，只要总线不处于忙的状态，全部的ECU都可以在总线上发现相关报文。</p><p>那么有没有可能存在一种情况，比如ECU1和ECU2同时请求在总线上发报文？</p><p>实际上这种情况是存在的，这就牵扯到CAN通信的另一个知识点，仲裁机制。</p><p>在介绍仲裁机制之前，先让我们来了解一下CAN通信发送的数据是什么样子的。此处以最简单的CAN通信报文为例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAN通信&quot;&gt;&lt;a href=&quot;#CAN通信&quot; class=&quot;headerlink&quot; title=&quot;CAN通信&quot;&gt;&lt;/a&gt;CAN通信&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;title: Windows平台下基于Hexo搭建的个人博客&lt;br&gt;date: 2020-12-02 22</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Windows平台下基于Hexo搭建的个人博客</title>
    <link href="http://example.com/2023/09/03/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>http://example.com/2023/09/03/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC/</id>
    <published>2023-09-03T02:17:25.806Z</published>
    <updated>2022-11-25T14:22:08.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-工具"><a href="#1-工具" class="headerlink" title="1.工具"></a>1.工具</h1><ul><li><p>1.1 <a href="https://nodejs.org/en/">node.js</a></p></li><li><p>1.2 <a href="https://git-scm.com/">git</a></p></li><li><p>1.3 npm(包含在node.js中)</p></li></ul><hr><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h1><ul><li><p>2.1 node.js的安装配置</p><ul><li>无脑下一步即可</li></ul></li><li><p>2.2 git的安装配置</p><ul><li><p>无脑下一步安装之后，桌面右键Git Bash</p></li><li><p><code>git config --global (user.name)</code> (github的用户名称)</p></li><li><p><code>git config --global (user.email)</code>（github的注册邮箱）</p></li><li><p>生成ssh密钥文件······</p></li><li><p>具体参考：<a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p></li><li><p>作用：<strong>保证后期将站点推到github时不需要多次重复输入账号密码</strong></p></li></ul></li><li><p>2.3 安装Hexo</p><ul><li><p>用管理员身份打开命令行，输入<code>node -v</code>可查看当前安装node.js的版本号</p></li><li><p>输入<code>npm -v</code>可查看当前安装npm的版本号</p></li></ul></li></ul><ul><li><p>2.3.1 npm 直接安装Hexo框架</p><ul><li><p><code>npm install -g hexo-cli</code></p></li><li><p>-g 为全局安装</p></li><li><p>这个安装过程会相对较长，需要耐心等待</p></li></ul></li><li><p>2.3.2 利用npm 安装cnpm 间接安装hexo框架</p><ul><li><p><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></p></li><li><p>–registry 为镜像源</p></li><li><p>安装淘宝的镜像源，注意需要管理员权限</p></li><li><p>可以敲击<code>cnpm</code> &amp; <code>cnpm -v</code> 查看是否安装成功</p></li><li><p>利用 <code>cnpm install -g hexo-cli</code>安装<code>hexo</code>框架 </p></li><li><p>利用 <code>hexo-v</code> 可以查看是否安装成功</p></li></ul></li><li><p>2.4 利用Hexo正式搭建博客框架</p><ul><li><p><code>md blog</code>创建新的文件夹，之后的blog全部放在此处</p></li><li><p><code>cd blog</code>进入创建好的文件夹</p></li><li><p><code>hexo_init</code>初始化hexo博客，注意使用管理员命令，需要一点时间</p></li><li><p>可以在blog文件夹中查看生成的文件</p></li><li><p><code>hexo s</code> 启动博客（在本地4000生成）</p></li><li><p><code>ctrl + C</code> 可以终止本地预览</p></li><li><p><code>hexo n &quot;new paper&quot;</code> 可以新建一个新的 <code>md</code>文件，用来写博客文章</p></li><li><p><code>hexo g</code> 生成新的博客 </p></li><li><p><code>hexo s</code> 启动博客</p></li><li><p><code>hexo s</code>本地启动使用，用作测试使用</p></li></ul></li><li><p>2.5 把博客部署到GitHub上</p><ul><li><p>打开个人的<code>GitHub</code>,<code>Create a new repository</code>注意仓库名称必须为</p></li><li><p><code>user&#39;s name.github.io</code> <code>user&#39;s</code>为个人GitHub上的用户名称</p></li><li><p>在<code>blog</code>目录下安装<code>git</code>的部署插件</p></li><li><p>命令:<code>cnpm install --save hexo-deployer-git</code></p></li><li><p>配置 <code>blog</code>目录下<code>_config.yml</code>文件</p></li><li><p>在<code>_config.yml</code>文件下找到 <code>deploy</code>路径，修改如下</p></li><li><p><code>deploy:</code></p></li><li><p><code>type: &#39;git&#39;</code></p></li><li><p><code>repo: https://github.com/user&#39;s Https&#39;s address</code>  user’s Https’s address 填写之前创建的库的https地址</p></li><li><p><code>branch: master</code></p></li><li><p>部署到远端，注意后面必须添加空格</p></li><li><p><code>hexo d</code>命令</p></li><li><p>首次部署需要输入个人GitHub账号和密码</p></li><li><p>如果上一步部署好 <code>git</code>命令，下次不需要重新输出账号和密码</p></li></ul></li></ul><hr><h1 id="3-部署到个人域名"><a href="#3-部署到个人域名" class="headerlink" title="3.部署到个人域名"></a>3.部署到个人域名</h1><ul><li><p>3.1 购买域名</p><ul><li>国内购买主要是通过 <strong><a href="https://account.aliyun.com/">阿里云</a></strong> 和 <strong><a href="https://dnspod.cloud.tencent.com/">腾讯云</a></strong> ，这里通过 <strong><a href="https://account.aliyun.com/">阿里云</a></strong> 作为演示</li></ul></li><li><p>3.2 解析域名</p><ul><li><p>购买域名之后,点击对应域名的 <strong>解析</strong>， <strong>添加解析</strong></p></li><li><p>记录类型选择 <strong>CNAME</strong>  记录值改为 <strong>mrduan-96.github.io</strong> 为创建的github的库名称  主机记录为 <strong>www</strong> 其他选择为默认即可</p></li><li><p>记录类型选择 <strong>CNAME</strong> 记录值改为 <strong>mrduan-96.github.io</strong>  为创建的github的库名称  主机记录为 <strong>@</strong> 其他选择为默认即可</p></li></ul></li><li><p>3.3 创建 <strong>CNAME</strong> 文件</p><ul><li><p>在本地博客目录下的 <code>source</code> 文件夹中，新建一个名为 <code>CNAME</code> 的文件，注意这个文件不带 <code>任何后缀名</code></p></li><li><p>打开<code>CNAME</code> 的文件，在里面添加自己购买的域名，注意添加的域名不带 <code>http://</code> 也不带 <code>www</code> </p></li><li><p>保存文件，再次推到网站即可</p></li></ul></li></ul><hr><h1 id="4-主题和总结"><a href="#4-主题和总结" class="headerlink" title="4.主题和总结"></a>4.主题和总结</h1><ul><li><p>4.1 主题</p><ul><li><p><code>_config.yml</code> 文件内 <code>theme</code>下可更换为其他位于 <code>themes</code> 文件夹目录下的其他主题</p></li><li><p>只需要更换主题名称即可</p></li></ul></li><li><p>4.2 总结</p><ul><li><p><code>npm install -g hexo-cli</code>    安装hexo框架</p></li><li><p><code>hexo init</code>                 初始化博客</p></li><li><p><code>hexo n &quot;我的博客&quot;</code>              新建博客文本</p></li><li><p><code>hexo s</code>                    启动博客</p></li><li><p><code>hexo g</code>                    生成博客</p></li><li><p><code>hexo d</code>                    部署到远端</p></li><li><p><code>hexo clean</code>                清理缓存</p></li><li><p><code>hexo server </code>                #Hexo会监视文件变动并自动更新，无须重启服务器</p></li><li><p><code>hexo server -s </code>            #静态模式</p></li><li><p><code>hexo server -p 5000 </code>        #更改端口</p></li><li><p><code>hexo server -i 192.168.1.1</code>#自定义 IP</p></li><li><p><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code>  #下载yilia主题到本地</p></li></ul></li></ul><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>Codesheep: <a href="https://www.bilibili.com/video/BV1Yb411a7ty?t=2">https://www.bilibili.com/video/BV1Yb411a7ty?t=2</a></p><p>Zhihu: <a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p><p><a href="https://juejin.cn/post/6844903688960475144">https://juejin.cn/post/6844903688960475144</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-工具&quot;&gt;&lt;a href=&quot;#1-工具&quot; class=&quot;headerlink&quot; title=&quot;1.工具&quot;&gt;&lt;/a&gt;1.工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.1 &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;node.js&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Windows平台下基于Hexo搭建的个人博客</title>
    <link href="http://example.com/2023/09/03/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>http://example.com/2023/09/03/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%20-%20%E5%89%AF%E6%9C%AC/</id>
    <published>2023-09-03T02:09:43.481Z</published>
    <updated>2022-11-25T14:22:08.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-工具"><a href="#1-工具" class="headerlink" title="1.工具"></a>1.工具</h1><ul><li><p>1.1 <a href="https://nodejs.org/en/">node.js</a></p></li><li><p>1.2 <a href="https://git-scm.com/">git</a></p></li><li><p>1.3 npm(包含在node.js中)</p></li></ul><hr><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h1><ul><li><p>2.1 node.js的安装配置</p><ul><li>无脑下一步即可</li></ul></li><li><p>2.2 git的安装配置</p><ul><li><p>无脑下一步安装之后，桌面右键Git Bash</p></li><li><p><code>git config --global (user.name)</code> (github的用户名称)</p></li><li><p><code>git config --global (user.email)</code>（github的注册邮箱）</p></li><li><p>生成ssh密钥文件······</p></li><li><p>具体参考：<a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p></li><li><p>作用：<strong>保证后期将站点推到github时不需要多次重复输入账号密码</strong></p></li></ul></li><li><p>2.3 安装Hexo</p><ul><li><p>用管理员身份打开命令行，输入<code>node -v</code>可查看当前安装node.js的版本号</p></li><li><p>输入<code>npm -v</code>可查看当前安装npm的版本号</p></li></ul></li></ul><ul><li><p>2.3.1 npm 直接安装Hexo框架</p><ul><li><p><code>npm install -g hexo-cli</code></p></li><li><p>-g 为全局安装</p></li><li><p>这个安装过程会相对较长，需要耐心等待</p></li></ul></li><li><p>2.3.2 利用npm 安装cnpm 间接安装hexo框架</p><ul><li><p><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></p></li><li><p>–registry 为镜像源</p></li><li><p>安装淘宝的镜像源，注意需要管理员权限</p></li><li><p>可以敲击<code>cnpm</code> &amp; <code>cnpm -v</code> 查看是否安装成功</p></li><li><p>利用 <code>cnpm install -g hexo-cli</code>安装<code>hexo</code>框架 </p></li><li><p>利用 <code>hexo-v</code> 可以查看是否安装成功</p></li></ul></li><li><p>2.4 利用Hexo正式搭建博客框架</p><ul><li><p><code>md blog</code>创建新的文件夹，之后的blog全部放在此处</p></li><li><p><code>cd blog</code>进入创建好的文件夹</p></li><li><p><code>hexo_init</code>初始化hexo博客，注意使用管理员命令，需要一点时间</p></li><li><p>可以在blog文件夹中查看生成的文件</p></li><li><p><code>hexo s</code> 启动博客（在本地4000生成）</p></li><li><p><code>ctrl + C</code> 可以终止本地预览</p></li><li><p><code>hexo n &quot;new paper&quot;</code> 可以新建一个新的 <code>md</code>文件，用来写博客文章</p></li><li><p><code>hexo g</code> 生成新的博客 </p></li><li><p><code>hexo s</code> 启动博客</p></li><li><p><code>hexo s</code>本地启动使用，用作测试使用</p></li></ul></li><li><p>2.5 把博客部署到GitHub上</p><ul><li><p>打开个人的<code>GitHub</code>,<code>Create a new repository</code>注意仓库名称必须为</p></li><li><p><code>user&#39;s name.github.io</code> <code>user&#39;s</code>为个人GitHub上的用户名称</p></li><li><p>在<code>blog</code>目录下安装<code>git</code>的部署插件</p></li><li><p>命令:<code>cnpm install --save hexo-deployer-git</code></p></li><li><p>配置 <code>blog</code>目录下<code>_config.yml</code>文件</p></li><li><p>在<code>_config.yml</code>文件下找到 <code>deploy</code>路径，修改如下</p></li><li><p><code>deploy:</code></p></li><li><p><code>type: &#39;git&#39;</code></p></li><li><p><code>repo: https://github.com/user&#39;s Https&#39;s address</code>  user’s Https’s address 填写之前创建的库的https地址</p></li><li><p><code>branch: master</code></p></li><li><p>部署到远端，注意后面必须添加空格</p></li><li><p><code>hexo d</code>命令</p></li><li><p>首次部署需要输入个人GitHub账号和密码</p></li><li><p>如果上一步部署好 <code>git</code>命令，下次不需要重新输出账号和密码</p></li></ul></li></ul><hr><h1 id="3-部署到个人域名"><a href="#3-部署到个人域名" class="headerlink" title="3.部署到个人域名"></a>3.部署到个人域名</h1><ul><li><p>3.1 购买域名</p><ul><li>国内购买主要是通过 <strong><a href="https://account.aliyun.com/">阿里云</a></strong> 和 <strong><a href="https://dnspod.cloud.tencent.com/">腾讯云</a></strong> ，这里通过 <strong><a href="https://account.aliyun.com/">阿里云</a></strong> 作为演示</li></ul></li><li><p>3.2 解析域名</p><ul><li><p>购买域名之后,点击对应域名的 <strong>解析</strong>， <strong>添加解析</strong></p></li><li><p>记录类型选择 <strong>CNAME</strong>  记录值改为 <strong>mrduan-96.github.io</strong> 为创建的github的库名称  主机记录为 <strong>www</strong> 其他选择为默认即可</p></li><li><p>记录类型选择 <strong>CNAME</strong> 记录值改为 <strong>mrduan-96.github.io</strong>  为创建的github的库名称  主机记录为 <strong>@</strong> 其他选择为默认即可</p></li></ul></li><li><p>3.3 创建 <strong>CNAME</strong> 文件</p><ul><li><p>在本地博客目录下的 <code>source</code> 文件夹中，新建一个名为 <code>CNAME</code> 的文件，注意这个文件不带 <code>任何后缀名</code></p></li><li><p>打开<code>CNAME</code> 的文件，在里面添加自己购买的域名，注意添加的域名不带 <code>http://</code> 也不带 <code>www</code> </p></li><li><p>保存文件，再次推到网站即可</p></li></ul></li></ul><hr><h1 id="4-主题和总结"><a href="#4-主题和总结" class="headerlink" title="4.主题和总结"></a>4.主题和总结</h1><ul><li><p>4.1 主题</p><ul><li><p><code>_config.yml</code> 文件内 <code>theme</code>下可更换为其他位于 <code>themes</code> 文件夹目录下的其他主题</p></li><li><p>只需要更换主题名称即可</p></li></ul></li><li><p>4.2 总结</p><ul><li><p><code>npm install -g hexo-cli</code>    安装hexo框架</p></li><li><p><code>hexo init</code>                 初始化博客</p></li><li><p><code>hexo n &quot;我的博客&quot;</code>              新建博客文本</p></li><li><p><code>hexo s</code>                    启动博客</p></li><li><p><code>hexo g</code>                    生成博客</p></li><li><p><code>hexo d</code>                    部署到远端</p></li><li><p><code>hexo clean</code>                清理缓存</p></li><li><p><code>hexo server </code>                #Hexo会监视文件变动并自动更新，无须重启服务器</p></li><li><p><code>hexo server -s </code>            #静态模式</p></li><li><p><code>hexo server -p 5000 </code>        #更改端口</p></li><li><p><code>hexo server -i 192.168.1.1</code>#自定义 IP</p></li><li><p><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code>  #下载yilia主题到本地</p></li></ul></li></ul><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>Codesheep: <a href="https://www.bilibili.com/video/BV1Yb411a7ty?t=2">https://www.bilibili.com/video/BV1Yb411a7ty?t=2</a></p><p>Zhihu: <a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p><p><a href="https://juejin.cn/post/6844903688960475144">https://juejin.cn/post/6844903688960475144</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-工具&quot;&gt;&lt;a href=&quot;#1-工具&quot; class=&quot;headerlink&quot; title=&quot;1.工具&quot;&gt;&lt;/a&gt;1.工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.1 &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;node.js&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HDL Bits刷题总结</title>
    <link href="http://example.com/2022/11/26/hexo/HDL%20Bits%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%2067f40aed7eee45eba03b4205751421ea/"/>
    <id>http://example.com/2022/11/26/hexo/HDL%20Bits%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%2067f40aed7eee45eba03b4205751421ea/</id>
    <published>2022-11-26T07:34:11.482Z</published>
    <updated>2022-11-26T08:12:58.098Z</updated>
    
    <content type="html"><![CDATA[<aside>📉 此文章记录自己在HDL Bits刷题的经验，方便之后进行回忆和总结</aside><ul><li><p>00_Verilog Language</p><ul><li><p>Basic</p><ul><li><p>NOR gate 或非门</p>  <aside>  📉 与门：AND  非门 ：NOT   或门：OR  或非门：NOR  异非门：XOR       异或非门：XNOR          $Y=\overline{(A+B)}$  或非门→输入两信号同时为0 时，才可能输出高电平1  </aside>  [![ztbVW8.png](https://s1.ax1x.com/2022/11/26/ztbVW8.png)](https://imgse.com/i/ztbVW8)  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> a, </span><br><span class="line">    <span class="keyword">input</span> b, </span><br><span class="line">    <span class="keyword">output</span> out );</span><br><span class="line">    </span><br><span class="line"><span class="comment">//first way</span></span><br><span class="line">    <span class="keyword">assign</span> out = ~(a|b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li><li><p>XOR gate 异或门</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> a, </span><br><span class="line">    <span class="keyword">input</span> b, </span><br><span class="line">    <span class="keyword">output</span> out );</span><br><span class="line">    </span><br><span class="line"><span class="comment">//first way</span></span><br><span class="line">    <span class="keyword">assign</span> out = a^b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li><li><p>XNOR gate 异或非门</p>  <aside>  📉 异或非门：XNOR        $Y=\overline{(A+B)}$  </aside>  $$  vd  $$  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> a, </span><br><span class="line">    <span class="keyword">input</span> b, </span><br><span class="line">    <span class="keyword">output</span> out );</span><br><span class="line">    </span><br><span class="line"><span class="comment">//first way</span></span><br><span class="line">    <span class="keyword">assign</span> out = ~(a^b);</span><br><span class="line"><span class="comment">//second way</span></span><br><span class="line"><span class="keyword">assign</span> out = a ~^ b;</span><br><span class="line"><span class="comment">//third way</span></span><br><span class="line"><span class="keyword">assign</span> out = a ^~ b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li><li><p>Declaring wires 声明中间的线</p><p>  <a href="https://imgse.com/i/ztbeSS"><img src="https://s1.ax1x.com/2022/11/26/ztbeSS.png" alt="ztbeSS.png"></a></p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">default_nettype</span> none</span></span><br><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">input</span> c,</span><br><span class="line">    <span class="keyword">input</span> d,</span><br><span class="line">    <span class="keyword">output</span> out,</span><br><span class="line">    <span class="keyword">output</span> out_n   ); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> w1,w2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> w1 = a&amp;b;</span><br><span class="line">    <span class="keyword">assign</span> w2 = c&amp;d;</span><br><span class="line">    <span class="keyword">assign</span> out = w1|w2;    </span><br><span class="line">    <span class="keyword">assign</span> out_n = ~out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li><li><p>7458 Chip 芯片</p><p>  <a href="https://imgse.com/i/ztbmQg"><img src="https://s1.ax1x.com/2022/11/26/ztbmQg.png" alt="ztbmQg.png"></a></p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module ( </span><br><span class="line">    <span class="keyword">input</span> p1a, p1b, p1c, p1d, p1e, p1f,</span><br><span class="line">    <span class="keyword">output</span> p1y,</span><br><span class="line">    <span class="keyword">input</span> p2a, p2b, p2c, p2d,</span><br><span class="line">    <span class="keyword">output</span> p2y );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> p1_out1,p1_out2,p2_out1,p2_out2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> p1_out1 = p1a &amp; p1b &amp; p1c;</span><br><span class="line">    <span class="keyword">assign</span> p1_out2 = p1d &amp; p1e &amp; p1f;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> p2_out1 = p2a &amp; p2b;</span><br><span class="line">    <span class="keyword">assign</span> p2_out2 = p2c &amp; p2d;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> p1y = p1_out1 | p1_out2;</span><br><span class="line">    <span class="keyword">assign</span> p2y = p2_out1 | p2_out2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Vectors</p><ul><li><p>Vectors</p>  <aside>  📉  </aside></li><li></li></ul></li></ul></li><li><p>01_Circuits</p></li><li><p>02_Verification:Reading Simulations</p></li><li><p>03_Verification:Wirting Testbenches</p></li><li><p>04_CS450</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;aside&gt;
📉 此文章记录自己在HDL Bits刷题的经验，方便之后进行回忆和总结
&lt;/aside&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;00_Verilog Language&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Basic&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NOR gate 或非门&lt;/p</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Matlab 函数用法</title>
    <link href="http://example.com/2020/12/17/mod()%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2020/12/17/mod()%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2020-12-17T06:22:28.672Z</published>
    <updated>2022-11-25T14:22:14.882Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在学习Matlab的数学函数时，教程中提到取模（mod）与取余（rem）是不同的，今天在网上具体查了一下：</p><p>通常取模运算也叫取余运算，它们返回结果都是余数.rem和mod唯一的区别在于:<br>    当x和y的正负号一样的时候，两个函数结果是等同的；当x和y的符号不同时，rem函数结果的符号和x的一样，而mod和y一样。<br>    这是由于这两个函数的生成机制不同，rem函数采用fix函数，而mod函数采用了floor函数（这两个函数是用来取整的，fix函数向0方向舍入，floor函数向无穷小方向舍入）。<br>    rem（x，y）命令返回的是x-n.*y，如果y不等于0，其中的n = fix(x./y)，而mod(x,y)返回的是x-n.*y，当y不等于0时，n=floor(x./y)</p><p>两个异号整数取模取值规律 （当是小数时也是这个运算规律，这一点好像与C语言的不太一样）</p><p>先将两个整数看作是正数，再作除法运算<br>①能整除时，其值为0<br>②不能整除时，其值=除数×(整商+1)-被除数</p><p>例：mod(36,-10)=-4<br>即：36除以10的整数商为3，加1后为4；其与除数之积为40；再与被数之差为（40-36=4）；取除数的符号。所以值为-4。<br>例：mod(9,1.2)=0.6; </p><p>例：</p><blockquote><blockquote><p>mod(5,2)<br>ans =1                   %“除数”是正，“余数”就是正<br>mod(-5,2)<br>ans =1<br>mod(5,-2)<br>ans =-1                  %“除数”是负，“余数‘就是负<br>mod(-5,-2)<br>ans =-1                  %用rem时，不管“除数”是正是负，“余数”的符号与“被除数”的符号相同<br>rem(5,2)<br>ans =1                   %“被除数”是正，“余数”就是正<br>rem(5,-2);<br>ans =1<br>rem(-5,2)<br>ans =-1                 %“被除数”是负，“余数”就是负<br>rem(-5,-2)<br>ans =-1</p></blockquote></blockquote><p>慢慢体会，两者确实不一样</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天在学习Matlab的数学函数时，教程中提到取模（mod）与取余（rem）是不同的，今天在网上具体查了一下：&lt;/p&gt;
&lt;p&gt;通常取模运算也叫取余运算，它们返回结果都是余数.rem和mod唯一的区别在于:&lt;br&gt;    当x和y的正负号一样的时候，两个函数结果是等同的；当x</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Windows平台下基于Hexo搭建的个人博客</title>
    <link href="http://example.com/2020/12/02/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/"/>
    <id>http://example.com/2020/12/02/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/</id>
    <published>2020-12-02T14:28:07.664Z</published>
    <updated>2022-11-25T14:22:08.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-工具"><a href="#1-工具" class="headerlink" title="1.工具"></a>1.工具</h1><ul><li><p>1.1 <a href="https://nodejs.org/en/">node.js</a></p></li><li><p>1.2 <a href="https://git-scm.com/">git</a></p></li><li><p>1.3 npm(包含在node.js中)</p></li></ul><hr><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h1><ul><li><p>2.1 node.js的安装配置</p><ul><li>无脑下一步即可</li></ul></li><li><p>2.2 git的安装配置</p><ul><li><p>无脑下一步安装之后，桌面右键Git Bash</p></li><li><p><code>git config --global (user.name)</code> (github的用户名称)</p></li><li><p><code>git config --global (user.email)</code>（github的注册邮箱）</p></li><li><p>生成ssh密钥文件······</p></li><li><p>具体参考：<a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p></li><li><p>作用：<strong>保证后期将站点推到github时不需要多次重复输入账号密码</strong></p></li></ul></li><li><p>2.3 安装Hexo</p><ul><li><p>用管理员身份打开命令行，输入<code>node -v</code>可查看当前安装node.js的版本号</p></li><li><p>输入<code>npm -v</code>可查看当前安装npm的版本号</p></li></ul></li></ul><ul><li><p>2.3.1 npm 直接安装Hexo框架</p><ul><li><p><code>npm install -g hexo-cli</code></p></li><li><p>-g 为全局安装</p></li><li><p>这个安装过程会相对较长，需要耐心等待</p></li></ul></li><li><p>2.3.2 利用npm 安装cnpm 间接安装hexo框架</p><ul><li><p><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></p></li><li><p>–registry 为镜像源</p></li><li><p>安装淘宝的镜像源，注意需要管理员权限</p></li><li><p>可以敲击<code>cnpm</code> &amp; <code>cnpm -v</code> 查看是否安装成功</p></li><li><p>利用 <code>cnpm install -g hexo-cli</code>安装<code>hexo</code>框架 </p></li><li><p>利用 <code>hexo-v</code> 可以查看是否安装成功</p></li></ul></li><li><p>2.4 利用Hexo正式搭建博客框架</p><ul><li><p><code>md blog</code>创建新的文件夹，之后的blog全部放在此处</p></li><li><p><code>cd blog</code>进入创建好的文件夹</p></li><li><p><code>hexo_init</code>初始化hexo博客，注意使用管理员命令，需要一点时间</p></li><li><p>可以在blog文件夹中查看生成的文件</p></li><li><p><code>hexo s</code> 启动博客（在本地4000生成）</p></li><li><p><code>ctrl + C</code> 可以终止本地预览</p></li><li><p><code>hexo n &quot;new paper&quot;</code> 可以新建一个新的 <code>md</code>文件，用来写博客文章</p></li><li><p><code>hexo g</code> 生成新的博客 </p></li><li><p><code>hexo s</code> 启动博客</p></li><li><p><code>hexo s</code>本地启动使用，用作测试使用</p></li></ul></li><li><p>2.5 把博客部署到GitHub上</p><ul><li><p>打开个人的<code>GitHub</code>,<code>Create a new repository</code>注意仓库名称必须为</p></li><li><p><code>user&#39;s name.github.io</code> <code>user&#39;s</code>为个人GitHub上的用户名称</p></li><li><p>在<code>blog</code>目录下安装<code>git</code>的部署插件</p></li><li><p>命令:<code>cnpm install --save hexo-deployer-git</code></p></li><li><p>配置 <code>blog</code>目录下<code>_config.yml</code>文件</p></li><li><p>在<code>_config.yml</code>文件下找到 <code>deploy</code>路径，修改如下</p></li><li><p><code>deploy:</code></p></li><li><p><code>type: &#39;git&#39;</code></p></li><li><p><code>repo: https://github.com/user&#39;s Https&#39;s address</code>  user’s Https’s address 填写之前创建的库的https地址</p></li><li><p><code>branch: master</code></p></li><li><p>部署到远端，注意后面必须添加空格</p></li><li><p><code>hexo d</code>命令</p></li><li><p>首次部署需要输入个人GitHub账号和密码</p></li><li><p>如果上一步部署好 <code>git</code>命令，下次不需要重新输出账号和密码</p></li></ul></li></ul><hr><h1 id="3-部署到个人域名"><a href="#3-部署到个人域名" class="headerlink" title="3.部署到个人域名"></a>3.部署到个人域名</h1><ul><li><p>3.1 购买域名</p><ul><li>国内购买主要是通过 <strong><a href="https://account.aliyun.com/">阿里云</a></strong> 和 <strong><a href="https://dnspod.cloud.tencent.com/">腾讯云</a></strong> ，这里通过 <strong><a href="https://account.aliyun.com/">阿里云</a></strong> 作为演示</li></ul></li><li><p>3.2 解析域名</p><ul><li><p>购买域名之后,点击对应域名的 <strong>解析</strong>， <strong>添加解析</strong></p></li><li><p>记录类型选择 <strong>CNAME</strong>  记录值改为 <strong>mrduan-96.github.io</strong> 为创建的github的库名称  主机记录为 <strong>www</strong> 其他选择为默认即可</p></li><li><p>记录类型选择 <strong>CNAME</strong> 记录值改为 <strong>mrduan-96.github.io</strong>  为创建的github的库名称  主机记录为 <strong>@</strong> 其他选择为默认即可</p></li></ul></li><li><p>3.3 创建 <strong>CNAME</strong> 文件</p><ul><li><p>在本地博客目录下的 <code>source</code> 文件夹中，新建一个名为 <code>CNAME</code> 的文件，注意这个文件不带 <code>任何后缀名</code></p></li><li><p>打开<code>CNAME</code> 的文件，在里面添加自己购买的域名，注意添加的域名不带 <code>http://</code> 也不带 <code>www</code> </p></li><li><p>保存文件，再次推到网站即可</p></li></ul></li></ul><hr><h1 id="4-主题和总结"><a href="#4-主题和总结" class="headerlink" title="4.主题和总结"></a>4.主题和总结</h1><ul><li><p>4.1 主题</p><ul><li><p><code>_config.yml</code> 文件内 <code>theme</code>下可更换为其他位于 <code>themes</code> 文件夹目录下的其他主题</p></li><li><p>只需要更换主题名称即可</p></li></ul></li><li><p>4.2 总结</p><ul><li><p><code>npm install -g hexo-cli</code>    安装hexo框架</p></li><li><p><code>hexo init</code>                 初始化博客</p></li><li><p><code>hexo n &quot;我的博客&quot;</code>              新建博客文本</p></li><li><p><code>hexo s</code>                    启动博客</p></li><li><p><code>hexo g</code>                    生成博客</p></li><li><p><code>hexo d</code>                    部署到远端</p></li><li><p><code>hexo clean</code>                清理缓存</p></li><li><p><code>hexo server </code>                #Hexo会监视文件变动并自动更新，无须重启服务器</p></li><li><p><code>hexo server -s </code>            #静态模式</p></li><li><p><code>hexo server -p 5000 </code>        #更改端口</p></li><li><p><code>hexo server -i 192.168.1.1</code>#自定义 IP</p></li><li><p><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code>  #下载yilia主题到本地</p></li></ul></li></ul><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>Codesheep: <a href="https://www.bilibili.com/video/BV1Yb411a7ty?t=2">https://www.bilibili.com/video/BV1Yb411a7ty?t=2</a></p><p>Zhihu: <a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p><p><a href="https://juejin.cn/post/6844903688960475144">https://juejin.cn/post/6844903688960475144</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-工具&quot;&gt;&lt;a href=&quot;#1-工具&quot; class=&quot;headerlink&quot; title=&quot;1.工具&quot;&gt;&lt;/a&gt;1.工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.1 &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;node.js&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
